expect_equal(length(Cov_est$Mout),3)
})
test_that('Check case M as input works with fractional power', {
set.seed(1234321)
n=30 #sample size
m=15 #dimension of covariance matrices
M <- array(0,c(m,m,n))
for (i in 1:n){
y0=rnorm(m)
aux<-15*diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
x=matrix(rnorm(n),n)
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
Cov_est=LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=1/2))
expect_equal(length(Cov_est$Mout),3)
})
LocCovReg= function(x,y=NULL,M=NULL,xout,optns = list()){
if(is.null(optns$metric)){
metric <- "frobenius"
} else {
metric <- optns$metric
}
if(!metric %in% c("frobenius","power","cholesky","log_cholesky")){
stop("metric choice not supported.")
}
if(metric=="frobenius") {
res <- LFRCov(x=x, y=y,M=M,xout=xout,optns = optns)
} else if(metric=="power") {
res <- LFRCovPower(x=x, y=y,M=M,xout=xout,optns = optns)
} else{
if (is.null(M))
stop("M must be input for Cholesky and log-Cholesky metrics; y does not apply.")
res <- LFRCovCholesky(x=x, M=M, xout=xout, optns = optns)
}
class(res) <- "covReg"
return(res)
}
LFRCov  = function(x, y=NULL,M=NULL, xout,optns = list()){
if(is.null(optns$corrOut)){
corrOut=FALSE
} else{
corrOut=optns$corrOut
}
if(is.null(optns$kernel)){
kernel = 'gauss'
} else{
kernel=optns$kernel
}
if(is.null(optns$bwMean)){
bwMean = NA
} else{
bwMean=optns$bwMean
}
if(is.null(optns$bwCov)){
bwCov=NA
} else{
bwCov=optns$bwCov
}
bw2=bwCov
if(!is.matrix(x)){
stop('x must be a matrix')
}
if(!is.matrix(xout)){
stop('xout must be a matrix')
}
if(ncol(x) != ncol(xout)){
stop('x and xout must have the same number of columns')
}
p = ncol(x)
if(p > 2){
stop("The number of dimensions of the predictor x is greater than 2.")
}
m = nrow(xout)
Kern=kerFctn(kernel)
K = function(x,h){
k = 1
for(i in 1:p){
k=k*Kern(x[,i]/h[i])
}
return(as.numeric(k))
}
computeLFR=function(idx,x0,bw2){
#x0 and bw2 are in R^p
x=as.matrix(x[idx,])
aux=K(x-matrix(t(x0),nrow=length(idx),ncol=length(x0),byrow=TRUE),bw2)
mu0 = mean(aux)
mu1 = colMeans(aux*(x - matrix(t(x0),nrow=length(idx),ncol=length(x0),byrow=TRUE)))
mu2=0
for(i in 1:length(idx)){
mu2 = mu2 + aux[i]*(x[i,]-x0) %*% t(x[i,]-x0)/length(idx)
}
sL = array(0,length(idx))
for(i in 1:length(idx)){
sL[i] =aux[i]*(1-t(mu1)%*%solve(mu2)%*%(x[i,]-x0))
}
s = sum(sL)
if(s == 0){
stop('Bandwidth too small')
}
M_aux=array(0,c(dim(M)[1],dim(M)[1],1))
for(i in 1:length(idx)){
M_aux[,,1]=M_aux[,,1]+sL[i]*M[,,idx[i]]/s
}
M_aux[,,1]
}
if(!is.null(y)){
if(!is.matrix(y)){
stop('y must be a matrix')
}
if(nrow(x) != nrow(y)){
stop('x and y must have the same number of rows')
}
n = nrow(y)
nGrid = ncol(y)
cm = mean4LocCovReg(x=x,y=y,xout=x,list(bwMean = bwMean))
bwMean = cm$optns$bwMean
cmh = cm$mean_out
M=array(0,c(dim(y)[2], dim(y)[2], dim(y)[1]))
for(i in 1:n){
M[,,i] = (y[i,] - cmh[i,]) %*% t(y[i,] - cmh[i,])
}
if(is.na(sum(bw2))){
bw2 = bwMean
}
} else{
if(!is.null(M)){
if(is.list(M)){
M=array(as.numeric(unlist(M)), dim=c(dim(M[[1]])[1],dim(M[[1]])[1],length(M)))
}else{
if(!is.array(M)){
stop('M must be an array or a list')
}
}
if(nrow(x)!=dim(M)[3]){
stop("The number of rows of x must be the same as the number of covariance matrices in M")
}
#CV for bw2 selection
if(is.na(sum(bw2))){
delta=array(0,p)
for(j in 1:p){
delta[j]=(max(x[,j])-min(x[,j]))
}
if(p==1){
objF=matrix(0,nrow=20,ncol=1)
aux1=as.matrix(seq(delta[1]*0.01,delta[1]*0.2,length.out=20))
for(i in 1:20){
for(j in 1:dim(x)[1]){
aux=as.matrix(Matrix::nearPD(computeLFR(setdiff(1:dim(x)[1],j),x[j],aux1[i]),corr = FALSE)$mat)-M[,,j]
objF[i]=objF[i]+sum(diag(aux%*%t(aux)))
}
}
ind=which(objF==min(objF))[1]
bwCV=aux1[ind]
}
if(p==2){
objF=matrix(0,nrow=10,ncol=10)
aux1=seq(delta[1]*0.01,delta[1]*0.2,length.out=10)
aux2=seq(delta[2]*0.01,delta[2]*0.2,length.out=10)
for(i1 in 1:10){
for(i2 in 1:10){
for(j in 1:dim(x)[1]){
aux=as.matrix(Matrix::nearPD(computeLFR(setdiff(1:dim(x)[1],j),x[j,],c(aux1[i1],aux2[i2])),corr = FALSE)$mat)-M[,,j]
objF[i1,i2]=objF[i1,i2]+sum(diag(aux%*%t(aux)))
}
}
}
ind=which(objF==min(objF),arr.ind = TRUE)
bwCV=c(aux1[ind[1]],aux2[ind[2]])
}
bw2=bwCV
}
} else{
stop("y or M must be provided.")
}
}
Mout = list()
if(corrOut){
for(j in 1:m){
x0 = xout[j,]
aux=as.matrix(Matrix::nearPD(computeLFR(1:dim(x)[1],x0,bw2),corr=FALSE)$mat)
D=diag(1/sqrt(diag(aux)))
aux=D%*%aux%*%D
aux=as.matrix(Matrix::forceSymmetric(aux))
Mout = c(Mout,list(aux))
}
} else{
for(j in 1:m){
x0 = xout[j,]
Mout = c(Mout,list(as.matrix(Matrix::nearPD(computeLFR(1:dim(x)[1],x0,bw2),corr = FALSE)$mat)))
}
}
optns$corrOut=corrOut
optns$kernel=kernel
optns$bwMean=bwMean
optns$bwCov=bw2
return(list(xout=xout, Mout=Mout, optns=optns))
}
require(testthat)
test_that('error: x and xout must have same number of columns', {
set.seed(1234321)
n=200             # sample size
t=seq(0,1,length.out=100)       # length of data
x = cbind(rnorm(n),rnorm(n))
theta1 = theta2 = array(0,n)
for(i in 1:n){
theta1[i] = rnorm(1,x[i],x[i]^2)
theta2[i] = rnorm(1,x[i]/2,(1-x[i])^2)
}
y = matrix(0,n,length(t))
phi1 = sqrt(3)*t
phi2 = sqrt(6/5)*(1-t/2)
y = theta1%*%t(phi1) + theta2 %*% t(phi2)
xout = matrix(c(0.25,0.5,0.75),3)
expect_error(LocCovReg(x=x,y=y,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=3)),"x and xout must have the same number of columns")
})
test_that('error: x and xout must have same number of columns', {
set.seed(1234321)
n=200             # sample size
t=seq(0,1,length.out=100)       # length of data
x = cbind(rnorm(n),rnorm(n))
theta1 = theta2 = array(0,n)
for(i in 1:n){
theta1[i] = rnorm(1,x[i],x[i]^2)
theta2[i] = rnorm(1,x[i]/2,(1-x[i])^2)
}
y = matrix(0,n,length(t))
phi1 = sqrt(3)*t
phi2 = sqrt(6/5)*(1-t/2)
y = theta1%*%t(phi1) + theta2 %*% t(phi2)
xout = matrix(c(0.25,0.5,0.75),3)
expect_error(LocCovReg(x=x,y=y,xout=xout,optns=list(corrOut=FALSE,metric="frobenius")),"x and xout must have the same number of columns")
})
test_that('error: x and xout must have same number of columns', {
set.seed(1234321)
#Example M input
n=30 #sample size
m=30 #dimension of covariance matrices
M <- array(0,c(m,m,n))
for (i in 1:n){
y0=rnorm(m)
aux<-15*diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
x=cbind(rnorm(n),rnorm(n))
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
expect_error(LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=0)),"x and xout must have the same number of columns")
})
test_that('error: the number of rows of x must be the same as the number of covariance matrices in M', {
set.seed(1234321)
n=30 #sample size
m=30 #dimension of covariance matrices
M <- array(0,c(m,m,n+1))
for (i in 1:(n+1)){
y0=rnorm(m)
aux<-15*diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
x=matrix(rnorm(n),n)
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
expect_error(LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=0)),"The number of rows of x must be the same as the number of covariance matrices in M")
})
test_that('error: the number of rows of x must be the same as the number of covariance matrices in M', {
set.seed(1234321)
n=30 #sample size
m=30 #dimension of covariance matrices
M <- array(0,c(m,m,n+1))
for (i in 1:(n+1)){
y0=rnorm(m)
aux<-15*diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
x=matrix(rnorm(n),n)
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
expect_error(LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,metric="power")),"The number of rows of x must be the same as the number of covariance matrices in M")
})
test_that('Check correlation matrix output in the case p=2 with cross validation', {
set.seed(1234321)
n=30 #sample size
m=30 #dimension of covariance matrices
M <- array(0,c(m,m,n))
for (i in 1:n){
y0=rnorm(m)
aux<-15*diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
x=matrix(rnorm(n),n)
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
aux=LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=TRUE,metric="power",alpha=0))$Mout
expect_equal(sum(diag(aux[[1]])),m)
})
test_that('Check correlation matrix output in the case p=2 with cross validation', {
set.seed(1234321)
n=30 #sample size
m=15 #dimension of covariance matrices
M <- array(0,c(m,m,n))
for (i in 1:n){
y0=rnorm(m)
aux<-15*diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
x=matrix(rnorm(n),n)
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
aux=LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=TRUE))$Mout
expect_equal(sum(diag(aux[[1]])),m)
})
test_that('Check case y as input works power case', {
set.seed(1234321)
n=200             # sample size
t=seq(0,1,length.out=100)       # length of data
x = matrix(runif(n),n)
theta1 = theta2 = array(0,n)
for(i in 1:n){
theta1[i] = rnorm(1,x[i],x[i]^2)
theta2[i] = rnorm(1,x[i]/2,(1-x[i])^2)
}
y = matrix(0,n,length(t))
phi1 = sqrt(3)*t
phi2 = sqrt(6/5)*(1-t/2)
y = theta1%*%t(phi1) + theta2 %*% t(phi2)
xout = matrix(c(0.25,0.5,0.75),3)
Cov_est=LocCovReg(x=x,y=y,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=3))
expect_equal(length(Cov_est$Mout),3)
})
test_that('Check case y as input works frobenius', {
set.seed(1234321)
n=200             # sample size
t=seq(0,1,length.out=100)       # length of data
x = matrix(runif(n),n)
theta1 = theta2 = array(0,n)
for(i in 1:n){
theta1[i] = rnorm(1,x[i],x[i]^2)
theta2[i] = rnorm(1,x[i]/2,(1-x[i])^2)
}
y = matrix(0,n,length(t))
phi1 = sqrt(3)*t
phi2 = sqrt(6/5)*(1-t/2)
y = theta1%*%t(phi1) + theta2 %*% t(phi2)
xout = matrix(c(0.25,0.5,0.75),3)
Cov_est=LocCovReg(x=x,y=y,xout=xout,optns=list(corrOut=FALSE,metric="frobenius"))
expect_equal(length(Cov_est$Mout),3)
})
test_that('Check case M as input works', {
set.seed(1234321)
n=30 #sample size
m=15 #dimension of covariance matrices
M <- array(0,c(m,m,n))
for (i in 1:n){
y0=rnorm(m)
aux<-15*diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
x=matrix(rnorm(n),n)
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
Cov_est=LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE))
expect_equal(length(Cov_est$Mout),3)
})
test_that('Check Local Regression Simulated Setting Works (accurate estimate to the true target)', {
set.seed(1234321)
n=100000 #sample size
m=2 # dimension of covariance matrices
M <- array(0,c(m,m,n))
x<- cbind(runif(n,min=-1,max=1),runif(n,min=-1,max=1))
for (i in 1:n){
M[,,i]<-diag((2+x[i,]))
}
xout=cbind(0,0.5)
Cov_est=LFRCovPower(x=x,M=M,xout=xout,optns=list(alpha=1,corrOut=FALSE,bwCov=c(0.5,0.5)))
aux1=sum(abs(Cov_est$Mout[[1]]-diag(c(2,2.5))))
Cov_est=LFRCov(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,bwCov=c(0.5,0.5)))
aux2=sum(abs(Cov_est$Mout[[1]]-diag(c(2,2.5))))
if(aux1+aux2<=0.001){
flag=1
}else{
flag=0
}
expect_equal(flag,1)
})
test_that('Check Local Regression Simulated Setting Works (accurate estimate to the true target) on main Local function', {
set.seed(1234321)
n=100000 #sample size
m=2 # dimension of covariance matrices
M <- array(0,c(m,m,n))
x<- cbind(runif(n,min=-1,max=1),runif(n,min=-1,max=1))
for (i in 1:n){
M[,,i]<-diag((2+x[i,])^(1/3))
}
xout=cbind(0,0.5)
Cov_est=LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=3,bwCov=c(0.5,0.5)))
aux1=sum(abs(Cov_est$Mout[[1]]-diag(c(2,2.5)^(1/3))))
if(aux1<=0.001){
flag=1
}else{
flag=0
}
expect_equal(flag,1)
})
test_that('Check case y as input works fractional power', {
set.seed(1234321)
n=200             # sample size
t=seq(0,1,length.out=100)       # length of data
x = matrix(runif(n),n)
theta1 = theta2 = array(0,n)
for(i in 1:n){
theta1[i] = rnorm(1,x[i],x[i]^2)
theta2[i] = rnorm(1,x[i]/2,(1-x[i])^2)
}
y = matrix(0,n,length(t))
phi1 = sqrt(3)*t
phi2 = sqrt(6/5)*(1-t/2)
y = theta1%*%t(phi1) + theta2 %*% t(phi2)
xout = matrix(c(0.25,0.5,0.75),3)
Cov_est=LocCovReg(x=x,y=y,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=1/2))
expect_equal(length(Cov_est$Mout),3)
})
test_that('Check case M as input works with fractional power', {
set.seed(1234321)
n=30 #sample size
m=15 #dimension of covariance matrices
M <- array(0,c(m,m,n))
for (i in 1:n){
y0=rnorm(m)
aux<-15*diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
x=matrix(rnorm(n),n)
xout = matrix(c(0.25,0.5,0.75),3) #output predictor levels
Cov_est=LocCovReg(x=x,M=M,xout=xout,optns=list(corrOut=FALSE,metric="power",alpha=1/2))
expect_equal(length(Cov_est$Mout),3)
})
require(testthat)
test_that('Check M as input works', {
#Example M input as array
m=5 # dimension of covariance matrices
M <- array(0,c(m,m,2))
for (i in 1:2){
y0=rnorm(m)
aux<-diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
Covdist=CovFPowerDist(M=M,optns=list(metric="frobenius"))$dist
expect_equal(length(Covdist),1)
})
test_that('Check case M as input works: power metric case', {
#Example M input as array
m=5 # dimension of covariance matrices
M <- array(0,c(m,m,2))
for (i in 1:2){
y0=rnorm(m)
aux<-diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
Covdist=CovFPowerDist(M=M,optns=list(metric="power",alpha=2))$dist
expect_equal(length(Covdist),1)
})
test_that('Check case M as input works: power metric case', {
#Example M input as array
m=5 # dimension of covariance matrices
M <- array(0,c(m,m,2))
for (i in 1:2){
y0=rnorm(m)
aux<-diag(m)+y0%*%t(y0)
M[,,i]<-aux
}
Covdist=CovFPowerDist(M=M,optns=list(metric="power",alpha=0))$dist
expect_equal(length(Covdist),1)
})
test_that('Check power metric computation: frobenius case with power call and providing alpha 1', {
#Example M input as array
m=3 # dimension of covariance matrices
M <- array(0,c(m,m,2))
M[,,1]=diag(c(1,2,3))
M[,,2]=diag(c(2.5,1.2,4.8))
Covdist=CovFPowerDist(M=M,optns=list(metric="power",alpha=1))$dist
expect_equal(Covdist-sqrt(sum((c(1,2,3)-c(2.5,1.2,4.8))^2)),0)
})
test_that('Check power metric computation: frobenius case with power call without providing alpha', {
#Example M input as array
m=3 # dimension of covariance matrices
M <- array(0,c(m,m,2))
M[,,1]=diag(c(1,2,3))
M[,,2]=diag(c(2.5,1.2,4.8))
Covdist=CovFPowerDist(M=M,optns=list(metric="power"))$dist
expect_equal(Covdist-sqrt(sum((c(1,2,3)-c(2.5,1.2,4.8))^2)),0)
})
test_that('Check power metric computation: frobenius case with power call and providing alpha 1', {
#Example M input as array
m=3 # dimension of covariance matrices
M <- array(0,c(m,m,2))
M[,,1]=diag(c(1,2,3))
M[,,2]=diag(c(2.5,1.2,4.8))
Covdist=CovFPowerDist(M=M,optns=list(metric="frobenius"))$dist
expect_equal(Covdist-sqrt(sum((c(1,2,3)-c(2.5,1.2,4.8))^2)),0)
})
test_that('Check power metric computation: alpha 2.5', {
#Example M input as array
m=3 # dimension of covariance matrices
M <- array(0,c(m,m,2))
M[,,1]=diag(c(1,2,3))
M[,,2]=diag(c(2.5,1.2,4.8))
Covdist=CovFPowerDist(M=M,optns=list(metric="power",alpha=2.5))$dist
expect_equal(Covdist-sqrt(sum((c(1,2,3)^2.5-c(2.5,1.2,4.8)^2.5)^2))/2.5,0)
})
test_that('Check power metric computation: alpha 0', {
#Example M input as array
m=3 # dimension of covariance matrices
M <- array(0,c(m,m,2))
M[,,1]=diag(c(1,2,3))
M[,,2]=diag(c(2.5,1.2,4.8))
Covdist=CovFPowerDist(M=M,optns=list(metric="power",alpha=0))$dist
expect_equal(Covdist-sqrt(sum((log(c(1,2,3))-log(c(2.5,1.2,4.8)))^2)),0)
})
